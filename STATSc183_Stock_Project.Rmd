---
title: "STATS c183 Stock Project"
author: "Sam Schmall (904 483 518)"
date: "4/11/2018"
output: pdf_document
---
#First Submission

##Parts a, b, and c:  Importing and Calculations
```{r}
stocks <- read.csv("~/Downloads/stockData.csv", sep = ",", header = TRUE)

#Convert adjusted close prices into returns:
returns <- (stocks[-1,3:ncol(stocks)]-stocks[-nrow(stocks),3:ncol(stocks)])/stocks[-nrow(stocks),3:ncol(stocks)]
head(returns)
#Compute mean vector:
mean_vector <- colMeans(returns[-1])  #Without ^GSPC
head(mean_vector)
#Compute variance covariance matrix:
vcv_matrix <- cov(returns[-1])  #Without ^GSPC
head(vcv_matrix)
#Compute correlation matrix:
corr_matrix <- cor(returns[-1])   #Without ^GSPC
head(corr_matrix)
#Compute the vector of variances:
var_vector <- diag(vcv_matrix)
head(var_vector)
#Compute the vector of standard deviations:
stdev <- diag(vcv_matrix)^.5
head(stdev)
```
##Part d:  Initial Plot
```{r}
#Plot the 31 assets on the space expected return against standard deviation
library(ggplot2)
data <- as.data.frame(cbind(stdev, mean_vector))
#Add industry column to color code plot
data$Industry[1:6] <- "Biotechnology"
data$Industry[7:12] <- "Aerodefense"
data$Industry[13:18] <- "Entertainment - Diversified"
data$Industry[19:24] <- "Specialty Retail"
data$Industry[25:30] <- "Restaurants"
#Add name column
data$clicker <- rownames(data)
ggplot(data, aes(x = stdev, y = mean_vector, color = Industry, label = clicker)) + geom_point() + labs(x = "Standard Deviation", y = "Expected Return", title = "Portfolio Possibilities Curve") + geom_text(aes(label = clicker), hjust = 0, vjust = 0, check_overlap = TRUE) + geom_point(x = sd(returns$X.GSPC), y = mean(returns$X.GSPC), color = "Black") + geom_text(x = sd(returns$X.GSPC), y = mean(returns$X.GSPC) + .001, label = "S&P 500", check_overlap = TRUE, colour = "Black", fontface = "bold")
```

##Part e:  Equal Allocation Portfolio
```{r}
#Equal Allocation Portfolio
eap <- rep(1,30)/30
#Expected Return of EAP
Rbar_eap <- t(eap) %*% mean_vector
#Standard Deviation of EAP
stdev_eap <- (t(eap) %*% vcv_matrix %*% eap)^0.5
#New Plot
ggplot(data, aes(x = stdev, y = mean_vector, color = Industry, label = clicker)) + geom_point() + labs(x = "Standard Deviation", y = "Expected Return", title = "Portfolio Possibilities Curve") + geom_text(aes(label = clicker), hjust = 0, vjust = 0, check_overlap = TRUE) + geom_point(x = as.numeric(stdev_eap), y = as.numeric(Rbar_eap), colour = "Black") +geom_text(x = as.numeric(stdev_eap), y = as.numeric(Rbar_eap) + .001, label = "EAP", check_overlap = TRUE, colour = "Black", fontface = "bold") + geom_point(x = sd(returns$X.GSPC), y = mean(returns$X.GSPC), color = "Black") + geom_text(x = sd(returns$X.GSPC), y = mean(returns$X.GSPC) + .001, label = "S&P 500", check_overlap = TRUE, colour = "Black", fontface = "bold")
```

##Part f:  Minimum Risk Portfolio
```{r}
#Minimum Risk Portfolio
ones <- as.matrix(rep(1,30))
inv <- solve(vcv_matrix)
num <- inv %*% ones
denom <- t(ones) %*% inv %*% ones
mrp <- num/as.numeric(denom)

#Expected Return of MRP
rBar_mrp <- t(mrp) %*% mean_vector
#Standard Deviation of EAP
stdev_mrp <- (t(mrp) %*% vcv_matrix %*% mrp)^0.5

#New Plot
ggplot(data, aes(x = stdev, y = mean_vector, color = Industry, label = clicker)) + geom_point() + labs(x = "Standard Deviation", y = "Expected Return", title = "Portfolio Possibilities Curve") + geom_text(aes(label = clicker), hjust = 0, vjust = 0, check_overlap = TRUE) + geom_point(x = as.numeric(stdev_eap), y = as.numeric(Rbar_eap), colour = "Black") + geom_text(x = as.numeric(stdev_eap), y = as.numeric(Rbar_eap) + .001, label = "EAP", check_overlap = TRUE, colour = "Black", fontface = "bold") + geom_point(x = as.numeric(stdev_mrp), y = as.numeric(rBar_mrp), colour = "Black") + geom_text(x = as.numeric(stdev_mrp), y = as.numeric(rBar_mrp) + .001, label = "MRP", check_overlap = TRUE, colour = "Black", fontface = "bold", hjust = .5,vjust = 2.5) + scale_x_continuous(limits = c(0, 0.22)) + geom_point(x = sd(returns$X.GSPC), y = mean(returns$X.GSPC), color = "Black") + geom_text(x = sd(returns$X.GSPC), y = mean(returns$X.GSPC) + .001, label = "S&P 500", check_overlap = TRUE, colour = "Black", fontface = "bold")
```

----------------------------------------------------------------
#Update 1
##Part 1:  Hyperbola
```{r}
#From the Course Website, Hyperbola Handout
inv <- solve(vcv_matrix)
  temp <- 0
  for(i in 1:length(mean_vector)){
    for(j in 1:length(mean_vector)){
    temp <- temp + inv[i, j] * mean_vector[j]
    }
}
  A <- temp

  temp <- 0
  for(i in 1:length(mean_vector)){
    for(j in 1:length(mean_vector)){
      temp <- temp + inv[i, j] * mean_vector[i] * mean_vector[j]
    }
}
B <- temp

temp <- 0
for(i in 1:length(mean_vector)){
  for(j in 1:length(mean_vector)){
    temp <- temp + inv[i, j]
	} 
}
C <- temp

temp <- 0
D <- B*C - A^2

  ###
plot.new()
plot(x = stdev, y = mean_vector, xlab = "Risk (Standard Deviation", ylab = "Expected Returns", main = "Portfolio Possibilities Curve", xlim = c(-2*sqrt(1/C), 0.22), ylim = c(-2*A/C, 4*A/C)) + points(x = as.numeric(stdev_eap), y = as.numeric(Rbar_eap), col = "Red") + points(x = as.numeric(stdev_mrp), y = as.numeric(rBar_mrp), col = "Blue") + points(x = sd(returns$X.GSPC), y = mean(returns$X.GSPC), col = "Green")
text(as.numeric(stdev_eap)-.005, as.numeric(Rbar_eap)+.005, "EAP", col = "Red")
text(as.numeric(stdev_mrp)-.005, as.numeric(rBar_mrp)+.005, "MRP", col = "Blue")
text(sd(returns$X.GSPC), mean(returns$X.GSPC)+.005, "S&P 500", col = "Green")

#Plot center of the hyperbola:
    points(0, A/C, pch = 19, col = "pink")

#Plot transverse and conjugate axes:
    abline(v = 0, col = "pink") #Also this is the y-axis.
    abline(h = A/C, col = "pink")

#Plot the x-axis:
    abline(h = 0, col = "pink")
    
#Plot the minimum risk portfolio:
    points(sqrt(1/C), A/C, pch=19, col = "blue")
    
#Find the asymptotes:
    V <- seq(-1, 1, 0.001)
    A1 <- A/C + V * sqrt(D/C)
    A2 <- A/C - V * sqrt(D/C)
    points(V, A1, type = "l", col = "pink")
    points(V, A2, type = "l", col = "pink")

#Efficient frontier:
    minvar <- 1/C
    minE <- A/C
    sdeff <- seq((minvar)^0.5, 1, by = 0.0001)
    options(warn = -1)
    y1 <- (A + sqrt(D*(C*sdeff^2 - 1)))*(1/C) 
    y2 <- (A - sqrt(D*(C*sdeff^2 - 1)))*(1/C) 
    options(warn = 0)

    points(sdeff, y1, type = "l", col = "pink")
    points(sdeff, y2, type = "l", col = "pink")
```

##Part 2:  Find Two Portfolios on the Efficient Frontier
```{r}
#Using code from Handout 19 as a guide

#Trace out the efficient frontier.  We need to find two portfolios on the efficient frontier:

#Choose two risk free rates:
Rf1 <- 0.05
Rf2 <- 0.08

#Construct the vectors RA and RB: 
RA <- mean_vector-Rf1
RB <- mean_vector-Rf2

#Find the composition of the two portfolios A, B:
zA <- solve(vcv_matrix) %*% RA
xA <- zA/sum(zA)

zB <- solve(vcv_matrix) %*% RB
xB <- zB/sum(zB)


#Compute the expected return and variance of portfolios A and B.  Also compute the covariance between portfolio A an B:
RA_bar <- t(xA) %*% mean_vector
RB_bar <- t(xB) %*% mean_vector
var_A <- t(xA) %*% vcv_matrix %*% xA
var_B <- t(xB) %*% vcv_matrix %*% xB
cov_AB <- t(xA) %*% vcv_matrix %*% xB
sd_A <- var_A^.5
sd_B <- var_B^.5

#We can find now the portfolio possibilities curve by treating portfolios A and B as two stocks:

xa <- seq(-100, 100, 0.01)
xb <- 1-xa

#Compute the expected return and standard deviation for each combination of xa, xb:
sigma_p <- (xa^2*var_A + xb^2*var_B+ 2*xa*xb*cov_AB)^.5

rp_bar <- xa*RA_bar + xb*RB_bar


#Plot:
plot.new()
plot(x = stdev, y = mean_vector, xlab = "Risk (Standard Deviation", ylab = "Expected Returns", main = "Portfolio Possibilities Curve", xlim = c(-2*sqrt(1/C), 0.22), ylim = c(-2*A/C, 4*A/C)) + points(x = as.numeric(stdev_eap), y = as.numeric(Rbar_eap), col = "Red") + points(x = as.numeric(stdev_mrp), y = as.numeric(rBar_mrp), col = "Blue") + points(x = sd(returns$X.GSPC), y = mean(returns$X.GSPC), col = "Green")
lines(sigma_p, rp_bar, cex = 0.3, col = "Purple", xlim=c(0,0.2), ylim=c(0,0.35))
text(as.numeric(stdev_eap)-.005, as.numeric(Rbar_eap)+.005, "EAP", col = "Red")
text(as.numeric(stdev_mrp)-.005, as.numeric(rBar_mrp)+.005, "MRP", col = "Blue")
text(sd(returns$X.GSPC), mean(returns$X.GSPC)+.005, "S&P 500", col = "Green")
points(sd_A, RA_bar, col="Purple", pch=19, cex=0.6)
points(sd_B, RB_bar, col="Purple", pch=19, cex=0.6)
text(sd_A-0.005, RA_bar, "A", col = "Purple")
text(sd_B-0.005, RB_bar, "B", col = "Purple")
```

##Part 3:  Find the Point of Tangency and CAL
```{r}
#Using code from Handout 16 as a guideline

#Compute the inverse of the variance-covariance matrix:
var_covar_inv <- solve(vcv_matrix)
var_covar_inv

#Create the vector R:
Rf <- 0.002
R <- mean_vector-Rf
R

#Compute the vector Z:
z <- var_covar_inv %*% R
z

#Compute the vector X:
x <- z/sum(z)
x

#Compute the expected return of portfolio G:
R_Gbar <- t(x) %*% mean_vector
R_Gbar

#Compute the variance and standard deviation of portfolio G:
var_G <- t(x) %*% vcv_matrix %*% x
var_G

sd_G <- var_G^0.5
sd_G

#Compute the slope:
slope <- (R_Gbar-Rf)/(sd_G)
slope

#We have already two points on the line:  (0, 0.002) and (sd_G, R_Gbar)
#Find one more point (borrowing segment):
#(1.3*sd_G,  0.002+slope*(1.3*sd_G))



#Plot:
plot.new()
plot(x = stdev, y = mean_vector,xlab = "Risk (Standard Deviation", ylab = "Expected Returns", main = "Portfolio Possibilities Curve", xlim = c(-2*sqrt(1/C), 0.22), ylim = c(-2*A/C, 4*A/C)) + points(x = as.numeric(stdev_eap), y = as.numeric(Rbar_eap), col = "Red") + points(x = as.numeric(stdev_mrp), y = as.numeric(rBar_mrp), col = "Blue") + points(x = sd(returns$X.GSPC), y = mean(returns$X.GSPC), col = "Green")
lines(sigma_p, rp_bar, cex = 0.3, col = "Purple", xlim=c(0,0.2), ylim=c(0,0.35))
text(as.numeric(stdev_eap)-.005, as.numeric(Rbar_eap)+.005, "EAP", col = "Red")
text(as.numeric(stdev_mrp)-.005, as.numeric(rBar_mrp)+.005, "MRP", col = "Blue")
text(sd(returns$X.GSPC), mean(returns$X.GSPC)+.005, "S&P 500", col = "Green")
points(sd_A, RA_bar, col="purple", pch=19, cex=0.6)
points(sd_B, RB_bar, col="purple", pch=19, cex=0.6)
text(sd_A-0.005, RA_bar, "A", col = "Purple")
text(sd_B-0.005, RB_bar, "B", col = "Purple")
lines(c(0,sd_G, 1.3*sd_G),c(.002,R_Gbar,0.002+slope*(1.3*sd_G)), col = "Orange")

#Identify portfolio G:
points(sd_G, R_Gbar, cex=1, col="Orange", pch = 16)
text(sd_G-.001, R_Gbar+.003, "G", col = "Orange")

```

----------------------------------------------------------------
#Update 2
##Part 1:  Estimates
```{r}
ret_max <- as.matrix(returns)

x <- rep(0, 30)
xx <- matrix(x, ncol=6, nrow=30)
stock <- rep(0,30)
alpha <- rep(0,30)
beta <- rep(0,30)
mse <- rep(0,30)

for(i in 1:31){
alpha[i] <- lm(data=returns,formula=ret_max[,i] ~ ret_max[,1])$coefficients[1]
beta[i] <- lm(data=returns,formula=ret_max[,i] ~ ret_max[,1])$coefficients[2]
mse[i] <- sum(lm(data=returns, formula=ret_max[,i] ~ ret_max[,1])$residuals^2)/(nrow(ret_max)-2)
stock[i] <- i
}

#Stock 1 is S&P 500
xx <- (cbind(stock,alpha, beta, mse))
xx
```

##Part 2:  Matrix
```{r}
model <- lm(returns$X.GSPC ~ returns$AMGN+returns$GILD+returns$BIIB+returns$CELG+returns$ILMN+returns$NKTR+returns$BA+returns$LMT+returns$RTN+returns$SPR+returns$LLL+returns$UTX+returns$DIS+returns$CMCSA+returns$WWE+returns$TWX+returns$FOXA+returns$CBS+returns$ULTA+returns$EBAY+returns$ZUMZ+returns$TSCO+returns$BKS+returns$FLWS+returns$DPZ+returns$CMG+returns$CAKE+returns$RRGB+returns$MCD+returns$YUM)

vcov(model)
```

##Part 3:  Methods
```{r}
#Access the data for the two periods.
#Period 1: 2010-2015
per1 <- read.csv("~/Downloads/Period_1.csv", sep = ",", header = TRUE)
#Period 2: 2015-2018
per2 <- read.csv("~/Downloads/Period_2.csv", sep = ",", header = TRUE)

#Initialize the vectors and matrices.
#Period 1:
beta1 <- rep(0,30)
var_beta1 <- rep(0,30)
beta_adj1 <- rep(0,30)
#Drop the first column (date):
per1 <- per1[,2:32]

#Perform regression of each stock on the index and record beta and the
#variance of beta in period 1:
for(i in 1:30){
q <- lm(data=per1, formula=per1[,i] ~ per1[,5])
beta1[i] <- q$coefficients[2]
var_beta1[i] <- vcov(q)[2,2]
}

#Vasicek’s method:
for(i in 1:30){
beta_adj1[i] <- var_beta1[i]*mean(beta1)/(var(beta1)+var_beta1[i]) +
var(beta1)*beta1[i]/(var(beta1)+var_beta1[i])
}

#Compute betas for period 2:
beta2 <- rep(0,30)
#Drop the first column (date):
per2 <- per2[,2:32]
for(i in 1:4){
q <- lm(data=per2, formula=per2[,i] ~ per2[,5])
beta2[i] <- q$coefficients[2]
}

#Compare:
betas <- as.data.frame(cbind(beta1, beta2, beta_adj1))
betas

#Blume’s method: Forecast of betas:
blume <- lm(betas$beta2 ~ betas$beta1)
beta3 <- blume$coefficients[1]+blume$coefficients[2]*beta2
as.data.frame(beta3)
beta3

#Use Vasicek’s method to forecast betas:
beta_adj2 <- rep(0,30)
var_beta2 <- rep(0,30)
for(i in 1:30){
q2 <- lm(data=per2, formula=per2[,i] ~ per2[,5])
beta2[i] <- q2$coefficients[2]
var_beta2[i] <- vcov(q2)[2,2]
}
#Vasicek’s method:
for(i in 1:30){
beta_adj2[i] <- var_beta2[i]*mean(beta2)/(var(beta2)+var_beta2[i]) +
var(beta2)*beta2[i]/(var(beta2)+var_beta2[i])
}

#Compare the forecast betas using the two methods for period 3:
beta3 #Blume’s method.
beta_adj2 #Vasicek’s method.
```

--------------------------------------------------------------------
#Update 4
##Part 1:  Ranking the Betas
```{r}
x <- rep(0, 180)
xx <- matrix(x, ncol=6, nrow=30)
stock <- rep(0,30)
alpha <- rep(0,30)
beta <- rep(0,30)
mse <- rep(0,30)
Rbar <- rep(0,30)
Ratio <- rep(0,30)
col1 <- rep(0,30)
col2 <- rep(0,30)
col3 <- rep(0,30)
col4 <- rep(0,30)
col5 <- rep(0,30)

rf <- 0.002

b <- as.matrix(returns)

for(i in 2:31){
alpha[i] <- lm(data=returns,formula=returns[,i] ~ returns[,1])$coefficients[1]
beta[i] <- lm(data=returns,formula=returns[,i] ~ returns[,1])$coefficients[2]
Rbar[i] <- alpha[i]+beta[i]*mean(b[,1])
mse[i] <- sum(lm(data=returns, formula=returns[,i] ~ returns[,1])$residuals^2)/(nrow(b)-2)
Ratio[i] <- (Rbar[i]-rf)/beta[i]
stock[i] <- i
}

xx <- (cbind(stock,alpha, beta, Rbar, mse, Ratio))

aaa <- xx[order(-Ratio),]
aaa <- aaa[-31,]

col1 <- (aaa[,4]-rf)*aaa[,3]/aaa[,5]
col3 <- aaa[,3]^2/aaa[,5]
for(i in(1:30)) {
col2[i] <- sum(col1[1:i])
col4[i] <- sum(col3[1:i])
}

#Find Ci
for(i in (1:30)) {
col5[i] <- var(returns[,1])*col2[i]/(1+var(returns[,1])*col4[i])
}
col5

final_table <- cbind(aaa, col1, col2, col3, col4, col5)
final_table
```

##Part 2:  Point of Tangency
```{r}
#Short Sales Allowed
#Compute the Zi:
z_short <- (aaa[,3]/aaa[,5])*(aaa[,6]-col5[5])
#Compute the xi:
x_short <- z_short/sum(z_short)
#The final table when short sales allowed:
aaaa <- cbind(aaa, col1, col2, col3, col4, col5, z_short, x_short)
aaaa

Rbar <- Rbar[-1]

Rbar_SIM_SSA <- t(x_short) %*% Rbar
var_SIM_SSA <- t(x_short) %*% vcv_matrix %*% x_short
sd_SIM_SSA <- var_SIM_SSA^0.5

#Short Sales Not Allowed
#First create a matrix up to the maximum of col5:
table1 <- cbind(aaa, col1, col2, col3, col4, col5)
table2 <- table1[1:which(col5==max(col5)), ]
table2

stocks_left <- c(27,20,6,26,2,23,3,4,9,30,10)


#Compute the Zi:
z_no_short <- (table2[,3]/table2[,5])*(table2[,6]-max(col5))
#Compute the xi:
x_no_short <- z_no_short/sum(z_no_short)
#The final table when short sales are not allowed:
aaaaa <- cbind(table2, z_no_short, x_no_short)
aaaaa

Rbar_SIM_SSNA <- t(x_no_short) %*% Rbar[stocks_left]

vcv_SSNA <- vcv_matrix[stocks_left, stocks_left]
var_SIM_SSNA <- t(x_no_short) %*% vcv_SSNA %*% x_no_short
sd_SIM_SSNA <- var_SIM_SSNA^0.5



#New Plot
plot.new()
plot(x = stdev, y = mean_vector,xlab = "Risk (Standard Deviation)", ylab = "Expected Returns", main = "Portfolio Possibilities Curve", xlim = c(-2*sqrt(1/C), 0.22), ylim = c(-2*A/C, 4*A/C)) + points(x = as.numeric(stdev_eap), y = as.numeric(Rbar_eap), col = "Red") + points(x = as.numeric(stdev_mrp), y = as.numeric(rBar_mrp), col = "Blue") + points(x = sd(returns$X.GSPC), y = mean(returns$X.GSPC), col = "Green")
lines(sigma_p, rp_bar, cex = 0.3, col = "Purple", xlim=c(0,0.2), ylim=c(0,0.35))
text(as.numeric(stdev_eap)-.005, as.numeric(Rbar_eap)+.005, "EAP", col = "Red")
text(as.numeric(stdev_mrp)-.005, as.numeric(rBar_mrp)+.005, "MRP", col = "Blue")
text(sd(returns$X.GSPC), mean(returns$X.GSPC)+.005, "S&P 500", col = "Green")
points(sd_A, RA_bar, col="purple", pch=19, cex=0.6)
points(sd_B, RB_bar, col="purple", pch=19, cex=0.6)
text(sd_A-0.005, RA_bar, "A", col = "Purple")
text(sd_B-0.005, RB_bar, "B", col = "Purple")
lines(c(0,sd_G, 1.3*sd_G),c(.002,R_Gbar,0.002+slope*(1.3*sd_G)), col = "Orange")

#Identify portfolio G:
points(sd_G, R_Gbar, cex=1, col="Orange", pch = 16)
text(sd_G-.001, R_Gbar+.003, "G", col = "Orange")

#Add SSA Portfolio to Plot
points(sd_SIM_SSA, Rbar_SIM_SSA, cex=1, col="Cyan", pch = 16)
text(sd_SIM_SSA-.001, Rbar_SIM_SSA+.003, "SIM SSA", col = "Cyan")

#Add SSNA Portfolio to Plot
points(sd_SIM_SSNA, Rbar_SIM_SSNA, cex=1, col="HotPink", pch = 16)
text(sd_SIM_SSNA-.001, Rbar_SIM_SSNA+.003, "SIM SSNA", col = "HotPink")
```

##Part 3:  Efficient Frontier
```{r}
##############
Rbar_EF <- rep(0, 800)
sd_EF <- rep(0, 800)
rf <- 0
rf2 <- 0.02

########################
for(a in 1:800){
  rf <- rf + .00001
  
  x <- rep(0, 180)
  xx <- matrix(x, ncol=6, nrow=30)
  stock <- rep(0,30)
  alpha <- rep(0,30)
  beta <- rep(0,30)
  mse <- rep(0,30)
  Rbar <- rep(0,30)
  Ratio <- rep(0,30)
  col1 <- rep(0,30)
  col2 <- rep(0,30)
  col3 <- rep(0,30)
  col4 <- rep(0,30)
  col5 <- rep(0,30)
  
  
  b <- as.matrix(returns)
  
  for(i in 2:31){
    alpha[i] <- lm(data=returns,formula=returns[,i] ~ returns[,1])$coefficients[1]
    beta[i] <- lm(data=returns,formula=returns[,i] ~ returns[,1])$coefficients[2]
    Rbar[i] <- alpha[i]+beta[i]*mean(b[,1])
    mse[i] <- sum(lm(data=returns, formula=returns[,i] ~ returns[,1])$residuals^2)/(nrow(b)-2)
    Ratio[i] <- (Rbar[i]-rf)/beta[i]
    stock[i] <- i
  }
  
  xx <- (cbind(stock,alpha, beta, Rbar, mse, Ratio))
  
  aaa <- xx[order(-Ratio),]
  aaa <- aaa[-31,]
  
  col1 <- (aaa[,4]-rf)*aaa[,3]/aaa[,5]
  col3 <- aaa[,3]^2/aaa[,5]
  for(i in(1:30)) {
    col2[i] <- sum(col1[1:i])
    col4[i] <- sum(col3[1:i])
  }
  
  #Find Ci
  for(i in (1:30)) {
    col5[i] <- var(returns[,1])*col2[i]/(1+var(returns[,1])*col4[i])
  }
  
  final_table <- cbind(aaa, col1, col2, col3, col4, col5)
  
  #Short Sales Not Allowed
  #First create a matrix up to the maximum of col5:
  table1 <- cbind(aaa, col1, col2, col3, col4, col5)
  table2 <- table1[1:which(col5==max(col5)), ]
  table2
  
  stocks_left <- table2[,1]
  
  
  #Compute the Zi:
  z_no_short <- (table2[,3]/table2[,5])*(table2[,6]-max(col5))
  #Compute the xi:
  x_no_short <- z_no_short/sum(z_no_short)
  #The final table when short sales are not allowed:
  aaaaa <- cbind(table2, z_no_short, x_no_short)
  aaaaa
  
  Rbar_EF[a] <- t(x_no_short) %*% Rbar[stocks_left]
  
  vcv_SSNA <- vcv_matrix[stocks_left, stocks_left]
  var_SIM_SSNA <- t(x_no_short) %*% vcv_SSNA %*% x_no_short
  sd_EF[a] <- var_SIM_SSNA^0.5
}

#New Plot
plot.new()
plot(x = stdev, y = mean_vector,xlab = "Risk (Standard Deviation)", ylab = "Expected Returns", main = "Portfolio Possibilities Curve", xlim = c(-2*sqrt(1/C), 0.22), ylim = c(-2*A/C, 4*A/C)) + points(x = as.numeric(stdev_eap), y = as.numeric(Rbar_eap), col = "Red") + points(x = as.numeric(stdev_mrp), y = as.numeric(rBar_mrp), col = "Blue") + points(x = sd(returns$X.GSPC), y = mean(returns$X.GSPC), col = "Green")
lines(sigma_p, rp_bar, cex = 0.3, col = "Purple", xlim=c(0,0.2), ylim=c(0,0.35))
text(as.numeric(stdev_eap)-.005, as.numeric(Rbar_eap)+.005, "EAP", col = "Red")
text(as.numeric(stdev_mrp)-.005, as.numeric(rBar_mrp)+.005, "MRP", col = "Blue")
text(sd(returns$X.GSPC), mean(returns$X.GSPC)+.005, "S&P 500", col = "Green")
points(sd_A, RA_bar, col="purple", pch=19, cex=0.6)
points(sd_B, RB_bar, col="purple", pch=19, cex=0.6)
text(sd_A-0.005, RA_bar, "A", col = "Purple")
text(sd_B-0.005, RB_bar, "B", col = "Purple")
lines(c(0,sd_G, 1.3*sd_G),c(.002,R_Gbar,0.002+slope*(1.3*sd_G)), col = "Orange")

#Identify portfolio G:
points(sd_G, R_Gbar, cex=1, col="Orange", pch = 16)
text(sd_G-.001, R_Gbar+.003, "G", col = "Orange")

#Add SSA Portfolio to Plot
points(sd_SIM_SSA, Rbar_SIM_SSA, cex=1, col="Cyan", pch = 16)
text(sd_SIM_SSA-.001, Rbar_SIM_SSA+.003, "SIM SSA", col = "Cyan")

#Add SSNA Portfolio to Plot
points(sd_SIM_SSNA, Rbar_SIM_SSNA, cex=1, col="HotPink", pch = 16)
text(sd_SIM_SSNA-.001, Rbar_SIM_SSNA+.003, "SIM SSNA", col = "HotPink")

#Add New Efficient Frontier
points(sd_EF, Rbar_EF, cex=0.6, col="DarkRed", pch = 19)
```

--------------------------------------------------------------------
#Update 5
##Constant Correlation Model
```{r}
#From the website
#Compute the average correlation:
rho <- (sum(cor(returns[2:31]))-30)/(30*29)

#Initialize the vectors:
Rbar <- rep(0,30)
Rbar_f <- rep(0,30)
sigma <- rep(0,30)
Ratio <- rep(0,30)
col1 <- rep(0,30)
col2 <- rep(0,30)
col3 <- rep(0,30)
stock <- rep(0,30)

#Initialize the var-covar matrix:
y <- rep(0,900)
mat <- matrix(y, ncol=30, nrow=30)

for(i in 2:31){
Rbar[i] <- mean(returns[,i])
Rbar_f[i] <- Rbar[i]-0.0002
sigma[i] <- sd(returns[,i])
Ratio[i] <- Rbar_f[i]/sigma[i]
stock[i] <- i
}

#Initial table:
xx <- (cbind(Rbar, Rbar_f, sigma, Ratio))

#Order the table based on the excess return to sigma ratio:
aaa <- xx[order(-Ratio),]
aaa <- aaa[-31,]
aaa

#Create the last 3 columns of the table:

for(i in(1:30)) {
      
         col1[i] <- rho/(1-rho+i*rho)

         col2[i] <- sum(aaa[,4][1:i])
              }

#Compute the Ci:
for(i in (1:30)) {

          col3[i] <- col1[i]*col2[i]
              
               }

#Create the entire table until now:
xxx <- cbind(aaa, col1, col2, col3)
xxx
```

##Part 2:  Point of Tangency
```{r}
#SHORT SALES ALLOWED:
#Compute the Zi:
z <- (1/((1-rho)*xxx[,3]))*(xxx[,4]-xxx[,7][nrow(xxx)])

#Compute the xi:
x <- z/sum(z)

#The final table:
aaaa <- cbind(xxx, z, x)
aaaa

#SHORT SALES NOT ALLOWED:
#Find composition of optimum portfolio when short sales are not allowed:
aaaaa <- aaaa[1:which(aaaa[,7]==max(aaaa[,7])), ]
z_no <- (1/((1-rho)*aaaaa[,3]))*(aaaaa[,4]-aaaaa[,7][nrow(aaaaa)])
x_no <- z_no/sum(z_no)
#Final table:
a_no <- cbind(aaaaa, z_no, x_no)
a_no


#Var-covar matrix based on the constant correlation model:
for(i in 1:30){

	for(j in 1:30){

	if(i==j){
		mat[i,j]=aaaa[i,3]^2
		} else
                {
	mat[i,j]=rho*aaaa[i,3]*aaaa[j,3]
	        }
	        }
                }

#Calculate the expected return and sd of the point of tangency 
#when short sales allowed
sd_p_opt <- (t(x) %*% mat %*% x)^.5
R_p_opt <- t(x) %*% aaaa[,1]


#Calculate the expected return and sd of the point of tangency 
#when short sales are not allowed
sd_p_opt_no <- (t(x_no) %*% mat[1:which(aaaa[,7]==max(aaaa[,7])),1:which(aaaa[,7]==max(aaaa[,7]))] %*% x_no)^.5
R_p_opt_no <- t(x_no) %*% aaaaa[,1]



#New Plot
#New Plot
plot.new()
plot(x = stdev, y = mean_vector,xlab = "Risk (Standard Deviation)", ylab = "Expected Returns", main = "Portfolio Possibilities Curve", xlim = c(-2*sqrt(1/C), 0.22), ylim = c(-2*A/C, 4*A/C)) + points(x = as.numeric(stdev_eap), y = as.numeric(Rbar_eap), col = "Red") + points(x = as.numeric(stdev_mrp), y = as.numeric(rBar_mrp), col = "Blue") + points(x = sd(returns$X.GSPC), y = mean(returns$X.GSPC), col = "Green")
lines(sigma_p, rp_bar, cex = 0.3, col = "Purple", xlim=c(0,0.2), ylim=c(0,0.35))
text(as.numeric(stdev_eap)-.005, as.numeric(Rbar_eap)+.005, "EAP", col = "Red")
text(as.numeric(stdev_mrp)-.005, as.numeric(rBar_mrp)+.005, "MRP", col = "Blue")
text(sd(returns$X.GSPC), mean(returns$X.GSPC)+.005, "S&P 500", col = "Green")
points(sd_A, RA_bar, col="purple", pch=19, cex=0.6)
points(sd_B, RB_bar, col="purple", pch=19, cex=0.6)
text(sd_A-0.005, RA_bar, "A", col = "Purple")
text(sd_B-0.005, RB_bar, "B", col = "Purple")
lines(c(0,sd_G, 1.3*sd_G),c(.002,R_Gbar,0.002+slope*(1.3*sd_G)), col = "Orange")

#Identify portfolio G:
points(sd_G, R_Gbar, cex=1, col="Orange", pch = 16)
text(sd_G-.001, R_Gbar+.003, "G", col = "Orange")

#Add SSA Portfolio to Plot
points(sd_SIM_SSA, Rbar_SIM_SSA, cex=1, col="Cyan", pch = 16)
text(sd_SIM_SSA-.001, Rbar_SIM_SSA+.003, "SIM SSA", col = "Cyan")

#Add SSNA Portfolio to Plot
points(sd_SIM_SSNA, Rbar_SIM_SSNA, cex=1, col="HotPink", pch = 16)
text(sd_SIM_SSNA-.001, Rbar_SIM_SSNA+.003, "SIM SSNA", col = "HotPink")


#Add SSA Portfolio to Plot
points(sd_p_opt, R_p_opt, cex=1, col="Tan", pch = 16)
text(sd_p_opt-.001, R_p_opt+.003, "CCM SSA", col = "Tan")

#Add SSNA Portfolio to Plot
points(sd_p_opt_no, R_p_opt_no, cex=1, col="Brown", pch = 16)
text(sd_p_opt_no-.001, R_p_opt_no+.003, "CCM SSNA", col = "Brown")
```

--------------------------------------------------------------------
#Update 6
##Part 1:  Time Plots
```{r}
plot(stocks$X, ylim=c(-0.5, 0.5), ylab="Expected Return", xlab="Time", xaxt="n", col="pink")
axis(1, at=seq(0, 60, by=12),labels=seq(2010, 2015, by=1))
lines(returns$X.GSPC, lty=5, col="green")
lines(Rbar_eap, lty=4, col="blue")
```


##Part 2
```{r}
#Sharpe Ratios
sharpe_SIMSSA <- (Rbar_SIM_SSA - rf)/sd_SIM_SSA
sharpe_SIMSSA #Single Index Model, Short Sales Allowed

sharpe_SIMSSNA <- (Rbar_SIM_SSNA - rf)/sd_SIM_SSNA
sharpe_SIMSSNA #Single Index Model, Short Sales Not Allowed

sharpe_CCMSSA <- (R_p_opt - rf)/sd_p_opt
sharpe_CCMSSA #Constant Correlation Model, Short Sales Allowed

sharpe_CCMSSNA <- (R_p_opt_no - rf)/sd_p_opt_no
sharpe_CCMSSNA #Constant Correlation Model, Short Sakes Not Allowed

sharpe_EAP <- (Rbar_eap - rf)/stdev_eap
sharpe_EAP #Equal Allocation Portfolio

sharpe_MRP <- (rBar_mrp - rf)/stdev_mrp
sharpe_MRP #Minimum Risk Portfolio


#Differential Excess Return


#Treynor Measure


#Jensen's Index
```

##Part 3
See attached.

##Part 4
See attached.


Based on the Sharpe Ratios, the constant correlation model that allows short sales is clearly the best model available.  Unfortuantely, I was unable to finish this part of the project accurately (see parts 1 and 2) but will hopefully submit a late, updated model soon.  Based off of intuition and the other plots available, however, it is clear that both constant correlation models, with and without short sales allowed, allow for the greatets return with only a small amount of risk.  It is because of this that, if the time plots were accurate, that it would be evident that this is the case.







